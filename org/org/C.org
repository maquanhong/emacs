#+TITLE: C 笔记

#+OPTIONS: ^:nil

* include"" 与 include<> 的区别
- "" 是以当前路径为相对路径引用头文件
- <> 是以系统环境变量路径引用头文件

* include <iostream> 与 include <iostream.h>的区别
在C语言中不存在iostream.h这个头文件，
在C++语言中，include <iostream.h>是不正确的写法，即不是C++标准库的写法。
C++标准库中的写法是include <iostream>    using namespace std;
进化过程也许是 C--->C++--->C++标准  也许是退化过程

@<font color="#ff0000">@以下内容引用自网络</font>

C++标准库很大。非常大。难以置信的大。怎么个大法？这么说吧：在C++标准中，关于标准库的规格说明占了密密麻麻300多页，这还不包括标准C库，后者只是 "作为参考"（老实说，原文就是用的这个词）包含在C++库中。

当然，并非总是越大越好，但在现在的情况下，确实越大越好，因为大的库会包含大量的功能。标准库中的功能越多，开发自己的应用程序时能借助的功能就越多。C++库并非提供了一切（很明显的是，没有提供并发和图形用户接口的支持），但确实提供了很多。几乎任何事你都可以求助于它。

在归纳标准库中有些什么之前，需要介绍一下它是如何组织的。因为标准库中东西如此之多，你（或象你一样的其他什么人）所选择的类名或函数名就很有可能和标准库中的某个名字相同。为了避免这种情况所造成的名字冲突，实际上标准库中的一切都被放在名字空间std中（参见条款28）。但这带来了一个新问题。无数现有的C++代码都依赖于使用了多年的伪标准库中的功能，例如，声明在<iostream.h>，<complex.h>，<limits.h>等头文件中的功能。现有软件没有针对使用名字空间而进行设计，如果用std来包装标准库导致现有代码不能用，将是一种可耻行为。（这种釜底抽薪的做法会让现有代码的程序员说出比 "可耻" 更难听的话）

慑于被激怒的程序员会产生的破坏力，标准委员会决定为包装了std的那部分标准库构件创建新的头文件名。生成新头文件的方法仅仅是将现有C++头文件名中的 .h 去掉，方法本身不重要，正如最后产生的结果不一致也并不重要一样。所以<iostream.h>变成了<iostream>，<complex.h>变成了<complex>，等等。对于C头文件，采用同样的方法，但在每个名字前还要添加一个c。所以C的<string.h>变成了<cstring>，<stdio.h>变成了<cstdio>，等等。最后一点是，旧的C++头文件是官方所反对使用的（即，明确列出不再支持），但旧的C头文件则没有（以保持对C的兼容性）。实际上，编译器制造商不会停止对客户现有软件提供支持，所以可以预计，旧的C++头文件在未来几年内还是会被支持。
* Socket 编程
** sock_stream 和 SOCK_DGRAM
sock_stream   是有保障的（即能保证数据正确传送到对方）面向连接的SOCKET，多用于资料（如文件）传送。
sock_dgram   是无保障的面向消息的socket　，　主要用于在网络上发广播信息。
SOCK_STREAM是基于TCP的，数据传输比较有保障。SOCK_DGRAM是基于UDP的，专门用于局域网，基于广播
SOCK_DGRAM 是数据流,一般是tcp/ip协议的编程,SOCK_DGRAM分是数据抱,是udp协议网络编程
*** Tcp 和 udp的区别
- 基于连接与无连接
- 对系统资源的要求(tcp较多，udp少)
- udp程序结构简单
- 流模式与数据报模式
    - tcp保证数据正确性，udp可能丢包
    - tcp保证数据顺序，udp不保证
**** 具体编程时的区别
1. socket()的参数不同
1. udp server不需要调用listen和accept
1. udp收发数据用sendto/recvfrom函数
1. tcp：地址信息在connect/accept时确定
1. udp：在sendto/recvfrom函数中每次均需指定地址信息
1. udp： shutdown函数无效
** 第一件事就是用socket()建立一个socket
#+begin_src c
#include <sys/socket.h>
#include <sys/types.h>

int socket(int af, int type, int protocol) 
#+end_src
- 'int af'代表地址族或者称为socket所代表的域，通常有两个选项： 
    - AF_UNIX - 只在单机上使用。 
    - AF_INET - 可以在单机或其他使用DARPA协议(UDP/TCP/IP)的异种机通信。 


- 'int type'代表你所使用的连接类型，通常也有两种情况： 
  - SOCK_DGRAM - 用来建立没有连接的sockets，不能保证数据传输的可靠性。
  - SOCK_STREAM - 用来建立面向连接的sockets，可以进行可靠无误的的数据传输 
    
    在本文中，我们着重使用AF_INET地址族和SOCK_STREAM连接类型。 

- 'int protocol'通常设定为0。这样的目的是使系统选择默认的由协议族和连接类型所确定的协议。 

这个函数的返回值是一个文件描述句柄，如果在此期间发生错误则返回-1并且设定了相应的errno。 

所以一般创建一个socket就用
#+begin_src c
#include <sys/types.h> 
#include <sys/socket.h> 

int sockfd /* soon to be socket file descriptor */ 

sockfd = socket(AF_INET, SOCK_STREAM, 0) 
/* error checking here */ 
#+end_src


** 第二件事是把socket绑定到某个端口上。bind()函数
#+begin_src c

#include <sys/types.h> 
#include <sys/socket.h> 

int bind(int sockfd, struct sockaddr *name, int namelen) 
#+end_src

*** sockfd是从socket()调用得到的文件描述句柄。
*** name是一个指向sockaddr类型结构的一个指针。
**** 如果地址族被设定为AF_UNIX

#+begin_src c
struct sockaddr { 
u_short sa_family; 
char sa_data[14]; 
}; 
#+end_src
name.sa_family应当被设定为AF_UNIX。
name.sa_data应当包含最长为14个字节的文件名，这个文件名用来分配给socket。
namelen给出了文件名的具体长度。 
#+begin_src c
#include <sys/types.h> 
#include <sys.socket.h> 

struct sockaddr name; 
int sockfd; 

name.sa_family = AF_UNIX; 
strcpy(name.sa_data, "/tmp/whatever"); 

sockfd = socket(AF_UNIX, SOCK_STREAM, 0) 
/* error checking code here */ 

bind(sockfd, &name, strlen(name.sa_data) + sizeof(name.sa_family) 
/* error checking code here */ 
#+end_src
**** 如果地址族被设定为AF_INET
#+begin_src c
struct sockaddr_in { 
    short int sin_family; /* Address family */ 
    unsigned short int sin_port; /* Port number */ 
    struct in_addr sin_addr; /* Internet address */ 
    unsigned char sin_zero[8]; /* Same size as struct sockaddr */ 
}; 

#+end_src
- sin_family指代协议族，在socket编程中只能是AF_INET
- sin_port存储端口号（使用网络字节顺序），在linux下，端口号的范围0~65535,同时0~1024范围的端口号已经被系统使用或保留。
- sin_addr存储IP地址，使用in_addr这个数据结构
- sin_zero是为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节。

#+begin_src c
sockaddr_in mysock;
bzero((char*)&mysock,sizeof(mysock));
mysock.sa_family=AF_INET;
mysock.sin_port=htons(1234);//1234是端口号
mysock.sin_addr.s_addr=inet_addr("192.168.0.1");
#+end_src

具体实例
#+begin_src c
#include <stdio.h> 
#include <sys/types.h> 
#include <sys/socket.h> 
#include <errno.h> 

int sockfd, port = 23; 
struct sockaddr_in my_addr; 

if((sockfd=socket(AF_INET, SOCK_STREAM, 0)) == -1) 
{ 
printf("Socket Error, %d\n", errno); 
exit(1); 
} 

my_addr.sin_family = AF_INET; /* host byte order */ 
my_addr.sin_port = htons(port); /* see man htons for more information 
*/ 
my_addr.sin_addr.s_addr = htonl(INADDR_ANY); /* get our address */ 
bzero(&(my_addr.sin_zero), 8); /* zero out the rest of the space */ 

if((bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr))
 == -1) 
{ 
printf("Bind Error, %d\n", errno); 
close(sockfd); 
exit(1); 
} 
#+end_src

@<font color="#ff0000">bind()就是把一个指定的端口分配给要bind的socket。 以后就可以用这个端口来“听“网络的请求。bind()用于server端，一般端口都是well known，以便于提供服务。 端口分配后，其他socket不能再用这个端口。相当于告诉client端"要请求服务，往这个端口发"。 client端不用bind，每建一个socket系统会分配一个临时的端口，用完后再释放。谁叫它是client.@</font>


** 如果是服务器就可以listen()了，如果是客户端就可以connect()了。
*** 服务器listen()
当我们需要建立一个服务器的时候，我们需要有一种手段来监听输入的请求，而listen()函数正是提供这个功能。 
#+begin_src c
#include <sys/types.h> 
#include <sys/socket.h> 

int listen(int sockfd, int backlog); 
#+end_src

参数backlog是指一次可以监听多少个连接 

#+begin_src c
socket(); /* to create out socket file descriptor */ 
bind(); /* to give our socket a name */ 
listen(); /* listen for connection */ 

#+end_src
*** 客户端connect()
使用connect()函数可以和服务器建立链接。
#+begin_src c
#include <sys/types.h> 
#include <sys/socket.h> 

int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);  
#+end_src
- sockfd是我们建立的文件描述句柄，
- serv_addr是一个sockaddr结构，包含目的的地址和端口号，
- addrlen 被设定为sockaddr结构的大小。 

#+begin_src c

#include <string.h>  
#include <sys/types.h>  
#include <sys/socket.h>  

#define DEST_IP "132.241.5.10" 
#define DEST_PORT 23 

main() 
{ 
int sockfd; 
struct sockaddr_in dest_addr; /* will hold the destination addr */ 

sockfd = socket(AF_INET, SOCK_STREAM, 0); /* do some error checking! *
/ 

dest_addr.sin_family = AF_INET; /* host byte order */ 
dest_addr.sin_port = htons(DEST_PORT); /* short, network byte order */

dest_addr.sin_addr.s_addr = inet_addr(DEST_IP); 
bzero(&(dest_addr.sin_zero), 8); /* zero the rest of the struct */ 

connect(sockfd, (struct sockaddr *)&dest_addr, sizeof(struct sockaddr)
); 
/* error checking code here */ 
/* more code  
. 
. 
. 
*/ 
} 
#+end_src

** 当客户端发起链接的时候，服务器端可以accept()
当有人试图从服务器打开的端口登陆进来时服务器应该响应他，这个时候就要用到accept()函数了
#+begin_src c
#include <sys/types.h> 
#include <sys/socket.h> 

int accept(int sockfd, void *addr, int *addrlen); 
#+end_src

#+begin_src c
#include <string.h>  
#include <sys/types.h>  
#include <sys/socket.h>  

#define MYPORT 1500 /* the port users will be connecting to */ 
#define BACKLOG 5 /* how many pending connections queue will hold */ 

main() 
{ 
int sockfd, new_fd; /* listen on sock_fd, new connection on new_fd */ 

struct sockaddr_in my_addr; /* my address information */ 
struct sockaddr_in their_addr; /* connector's address information */ 
int sin_size; 

sockfd = socket(AF_INET, SOCK_STREAM, 0); /* do some error checking! *
/ 

my_addr.sin_family = AF_INET; /* host byte order */ 
my_addr.sin_port = htons(MYPORT); /* short, network byte order */ 
my_addr.sin_addr.s_addr = INADDR_ANY; /* auto-fill with my IP */ 
bzero(&(my_addr.sin_zero), 8); /* zero the rest of the struct */ 

/* did you remember your error checking? */ 
bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr)); 

listen(sockfd, BACKLOG); 

sin_size = sizeof(struct sockaddr_in); 
new_fd = accept(sockfd, &their_addr, &sin_size); 

#+end_src

这里我们要注意的是：我们用new_fd来完成所有的接收和发送的操作。如果在只有一个连接的情况下你可以关闭原来的sockfd用来防止更多的输入请求。 


** accept()之后，可以用send() recv()或者write() read()来发送和接受信息。

*** send()和recv()

#+begin_src c

#include <sys/types.h> 
#include <sys/socket.h> 

int send(int sockfd, const void *msg, int len, int flags); 
int recv(int sockfd, void *buf, int len, unsigned int flags); 

send(): 
sockfd - socket file descriptor 
msg - message to send 
len - size of message to send 
flags - read 'man send' for more info, set it to 0 for now :) 

recv(): 
sockfd - socket file descriptor 
buf - data to receive 
len - size of buf 
flags - same as flags in send() 

send() 例程: 
- ------ 

char *msg = "Hey there people"; 
int len, send_msg; 

/* code to create(), bind(), listen() and accept() */  

len = strlen(msg); 
bytes_sent = send(sockfd, msg, len, 0); 

- ------ 
recv() 例程: 
- ------ 

char *buf; 
int len, recv_msg; 

/* code to create(), bind(), listen() and accept() */ 

len = strlen(buf); 
recv_msg = recv(sockfd, buf, len, 0); 

#+end_src

*** write() 和 read()
必须头：
#+begin_src c
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>
#+end_src

- 关于write()
#+begin_src c
ssize_t write(int d,const void *buf,size_t nbytes);
#+end_src

调用成功返回成功写入的字节数，调用失败则返回-1。参数1为对象的句柄；参数2是写入的内容；参数3是前
者的大小。

- 关于read()
#+begin_src c
ssize_t read(int d,void *buf,size_t nbytes);
#+end_src

正常调用返回成功读入的字节数，当读到句柄对象的底部时返回0，调用失败返回-1。参数1为对象句柄；参
数2是读入容器的地址；参数3是前者的大小。

** close() and shutdown() 
传输结束时，应当关闭连接。 
#+begin_src c
#include <stdio.h> 

/* all you code */ 

close(sockfd); 
#+end_src

更保险的方法是用shutdown()来关闭连接。 

#+begin_src c
int shutdown(int sockfd, int how) 
#+end_src


参数how的选择： 
1 - 不允许接收更多的数据 
2 - 不允许发送更多的数据 
3 - 不允许接收和发送更多的数据(和close()一样) 
** 其他函数 获取站点名称获取地址，根据地址获取名称
*** getpeerbyname
服务器端得到与其链接的客户端信息。
#+begin_src c
#include <sys/socket.h> 

int getpeername(int sockfd, struct sockaddr *addr, int *addrlen); 

struct sockaddr_in name;
int namelen = sizeof(name);
.
.
.
if(getpeername(0,(struct sockaddr*)&name, &namelen)<0){
  syslog(LOG_ERR,"getpeername: %m");
  exit(1);
} else
  syslog(LOG_INFO,"Connection from %s",inet_ntoa(name.sin_addr));
#+end_src

*** gethostname
返回本地主机的标准主机名。
#include <Winsock2.h>
int PASCAL FAR gethostname(char FAR *name, int namelen);
name：   一个指向将要存放主机名的缓冲区指针。
namelen：缓冲区的长度。
#+begin_src c
#include <stdio.h>
#include <unistd.h>
int main()
{
char name[65];
gethostname(name, sizeof(name));
printf("hostname = %s\n", name);
}


#+end_src

*** gethostbyname
返回对应于给定主机名的包含主机名字和地址信息的hostent结构指针
#+begin_src c
#include <winsock2.h>
struct hostent FAR *PASCAL FAR gethostbyname(const char
FAR * name);
name：指向主机名的指针。
返回类型
struct hostent
{
char FAR * h_name;
char FAR * FAR * h_aliases;
short h_addrtype;
short h_length;
char FAR * FAR * h_addr_list;
};
Linux版
#include <netdb.h>
struct hostent *gethostbyname(const char * hostname);
返回：非空指针——成功，空指针——出错，同时设置h_errno

#+end_src
- h_name 正规的主机名字（PC）。
- h_aliases 一个以空指针结尾的可选主机名队列。
- h_addrtype 返回地址的类型，对于Windows Sockets，这个域总是PF_INET。
- h_legnth 每个地址的长度（字节数），对应于PF_INET这个域应该为4。
- h_addr_list 应该以空指针结尾的主机地址的列表，返回的地址是以网络顺序排列的
为了保证其他旧的软件的兼容性，h_addr_list[0]被定义为宏h_addr。

*** gethostbyaddr
返回对应于给定地址的主机信息。

#+begin_src c
#include <winsock.h>
struct hostent FAR *PASCAL FAR gethostbyaddr(const char
FAR * addr, int len, int type);
addr：指向网络字节顺序地址的指针。
len： 地址的长度，在AF_INET类型地址中为4。
type：地址类型，应为AF_INET。
注释
gethostbyaddr()返回对应于给定地址的包含主机名字和地址信息的hostent结构指针。结构的声明如下：
struct hostent {
char FAR * h_name;
char FAR * FAR * h_aliases;
short h_addrtype;
short h_length;
char FAR * FAR * h_addr_list;
};
结构的成员有
成员 用途
h_name 正规的主机名字（PC）。
h_aliases 一个以空指针结尾的可选主机名队列。
h_addrtype 返回地址的类型，对于Windows Sockets，这个域总是PF_INET。
h_legnth 每个地址的长度（字节数），对应于PF_INET这个域应该为4。
h_addr_list 应该以空指针结尾的主机地址的列表，返回的地址是以网络顺序排列的
为了保证其他旧的软件的兼容性，h_addr_list[0]被定义为宏h_addr。
#+end_src

- h_name 正规的主机名字（PC）。
- h_aliases 一个以空指针结尾的可选主机名队列。
- h_addrtype 返回地址的类型，对于Windows Sockets，这个域总是PF_INET。
- h_legnth 每个地址的长度（字节数），对应于PF_INET这个域应该为4。
- h_addr_list 应该以空指针结尾的主机地址的列表，返回的地址是以网络顺序排列的
为了保证其他旧的软件的兼容性，h_addr_list[0]被定义为宏h_addr。


** select函数说明
个人认为select函数的作用是循环检查几个文件描述符（套结字描述符）中是否有可以进行读、写，或者出现异常的描述符。
它并不代表blocking 或者 nonblocking。
blcoking是由函数调用所产生的。
一般情况下，在使用select之前，需要把一个描述符设置成nonblocking的模式，使描述符在执行读、写或是连接的时候，不会发生程序的blocking。而是使程序的blcoking发生在select函数的调用的时候。

#+begin_src C
select 函数：
select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
返回 0 : 在timeout结束时，没有任何描述符就绪，即没有任何描述符可读写。
返回 -1: 出错
返回>0 : 表示就绪的描述符的总数。


FD_ZERO (fd_set *set); 将一个文件描述符集合清零
FD_SET(int fd, fd_set *set); 将文件描述符fd加入到集合set中
FD_CLR(int fd, fd_set *set); 将文件描述符fd从集合set中删除
FD_ISSET(int fd, fd_set *set); 判断文件描述符fd是否存在于集合set中。

#+end_src


** 设置套结字描述符的非阻塞模式（nonblocking）
使用fcntl()函数。
#+begin_src C
# include <unistd.h>
# include <fcntl.h>


int fcntl(int fd,   //文件描述符
            int cmd , //不同的命令
             struct flock *lock) //设置记录锁的具体状态

sockfd = socket(AF_INET, SOCK_STREAM, 0);
fcntl(sockfd, F_SETFL, O_NONBLOCK);

#+end_src

此函数功能强大的多，先写这么多。

** fcntl 和 select函数的结合
先用fcntl设置套结字的nonblocking模式，再用select循环检测套结字的可读写状态。
* gdb 调试工具

[[http://blog.csdn.net/liigo/archive/2006/01/17/582231.aspx][GDB 十分钟教程]]

* C语言防止头文件重复调用
[[http://www.cnblogs.com/IamEasy_Man/archive/2009/10/21/1587658.html][关于防止头文件重复调用和变量重复定义的网页说明]]


使用条件编译，在所有头文件中都如下编写
#+begin_src C
#ifndef _HEADERNAME_H
#define _HEADERNAME_H
// 头文件内容

#endif

#+end_src

这样多重包含的危险就被消除了。当头文件第一次被包含时，它被正常处理，符号_HEADERNAME_H被定义为1， 如果头文件再次被包含，通过条件编译，它的内容被忽略。符号_HEADERNAME_H按照被包含头文件的文件名进行取名，以避免由于其他头文件使用相同的符号而引起的冲突。

但是，预处理器仍将整个头文件读入，即使这个头文件所有内容被忽略，由于这种处理将托慢编译速度，如有可能，应该避免出现多重包含。
* C语言防止变量被重复定义
因为工程中的每个C文件都是独立的解释，即使在头文件中有#ifndef #define #endif之类的预定义，但不同的C文件引用的H文件中有重名变量，由于C文件独立解释，所以每个C文件都生成单独的O文件，再链接的时候，因为每个.O文件中都包含同一个重名变量，重名变量就会出现重复定义错误。

** 解决办法
- 在C文件中声明变量
- 然后建立一个头文件（.h文件）在所有的变量声明前都加上extern
- 但不用对变量进行初始化
- 然后在其他需要使用全局变量的.c文件中都包含此.h文件。
- 在编译器会为.c生成目标文件，然后链接时，如果该.c文件使用了全局变量，连接器就会连接到此.c文件。

* C语言指针
** 定义指针
int *ptr1;
int* ptr2;
两种方式都对，@<font color="#ff0000">所以‘*’并不是和int结合来指定int类型的指针@
</font>

第一种方式可以避免误解
int* ptr1, ptr2;
这样的定义方式，容易把ptr2也误认为是指针
** 指针的运算
*** & (address-of operator)
取指针的地址
*** * (Dereference operator)
*在定义时用来说明一个变量是指针，
而在定义一个指针之后，*表示取指针所指向的对象（变量）

* C语言引用传递
在C中，没有类似C++的引用传递。但可以用指针的方式来改变函数参数的值。

#+begin_src C
//This program is to test whether a function can change the parameter's 
//value in .c files.
//also provides how we can change the value(use pointer!). YES, use pointer!
#include<stdio.h>
void changeInt(int *a)
{
*a=3;
}
void changeChar(char** c)
{
*c="changed!";
}
void main()
{
int a=0;
char *c="hello";
changeChar(&c);
printf("%s\n",c);//print 'changed!'
changeInt(&a);
printf("%d\n",a);//out: 3
}

#+end_src


#+begin_src C
/* Swap function */
void swap(int* a,int* b)
{
*a=*a-*b;
*b=*b+*a;
*a=*b-*a;
}
/* Main function */
void main()
{
int i=3,j=1;
swap(&i,&j); //如果数组的话 则可用这种形式：swap(&(a[i]),&(a[i+1]));
printf("j:%d ",j);//3
printf("i:%d\n",i);//i
}

#+end_src

* 堆和栈
- 栈：由编译器自动分配释放。
- 堆：有程序员分配释放。

* end

----------
